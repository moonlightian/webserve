
定时器处理非活动连接
===============
由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.
> * 统一事件源
> * 基于升序链表的定时器
> * 处理非活动连接
> 
# 信号的异步
信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

Linux下的信号采用的异步处理机制，信号处理函数和当前进程是两条不同的执行路线。具体的，当进程收到信号时，操作系统会中断进程当前的正常流程，转而进入信号处理函数执行操作，完成后再返回中断的地方继续执行。

为避免信号竞态现象发生，信号处理期间系统不会再次触发它，即屏蔽。所以，为确保该信号不被屏蔽太久，信号处理函数需要尽可能快地执行完毕。

一般的信号处理函数需要处理该信号对应的逻辑，当该逻辑比较复杂时，信号处理函数执行时间过长，会导致信号屏蔽太久。

这里的解决方案是，信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。

## 统一事件源：

创建管道，其中管道写端写入信号值，管道读端通过I/O复用系统epoll监测读事件

设置信号处理函数SIGALRM（时间到了触发）和SIGTERM（kill会触发，Ctrl+C）

通过struct sigaction结构体和sigaction函数注册信号捕捉函数（捕捉到了SIGALRM或者SIGTERM后向管道写入信号）

利用epoll I/O复用系统监听管道读端文件描述符的可读事件

信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码

```cpp
 1//创建管道套接字，用来传递信号
 2ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);
 3assert(ret != -1);
 4
 5//设置管道写端为非阻塞，为什么写端要非阻塞？
 6setnonblocking(pipefd[1]);
 7
 8//设置管道读端为ET非阻塞
 9addfd(epollfd, pipefd[0], false);
10
11//传递给主循环的信号值，这里只关注SIGALRM和SIGTERM
12addsig(SIGALRM, sig_handler, false);
13addsig(SIGTERM, sig_handler, false);
14
15//循环条件
16bool stop_server = false;
17
18//超时标志
19bool timeout = false;
20
21//每隔TIMESLOT时间触发SIGALRM信号
22alarm(TIMESLOT);
23
24while (!stop_server)
25{
26    //监测发生事件的文件描述符
27    int number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);
28    if (number < 0 && errno != EINTR)
29    {
30        break;
31    }
32
33    //轮询文件描述符
34    for (int i = 0; i < number; i++)
35    {
36        int sockfd = events[i].data.fd;
37
38        //管道读端对应文件描述符发生读事件
39        if ((sockfd == pipefd[0]) && (events[i].events & EPOLLIN))
40        {
41            int sig;
42            char signals[1024];
43
44            //从管道读端读出信号值，成功返回字节数，失败返回-1
45            //正常情况下，这里的ret返回值总是1，只有14和15两个ASCII码对应的字符
46            ret = recv(pipefd[0], signals, sizeof(signals), 0);
47            if (ret == -1)
48            {
49                // handle the error
50                continue;
51            }
52            else if (ret == 0)
53            {
54                continue;
55            }
56            else
57            {
58                //处理信号值对应的逻辑
59                for (int i = 0; i < ret; ++i)
60                {
61                    //这里面明明是字符
62                    switch (signals[i])
63                    {
64                    //这里是整型
65                    case SIGALRM:
66                    {
67                        timeout = true;
68                        break;
69                    }
70                    case SIGTERM:
71                    {
72                        stop_server = true;
73                    }
74                    }
75                }
76            }
77        }
78    }
79}
```
## 为什么管道写端要非阻塞？

send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。

## 没有对非阻塞返回值处理，如果阻塞是不是意味着这一次定时事件失效了？

是的，但定时事件是非必须立即处理的事件，可以允许这样的情况发生。

## 管道传递的是什么类型？switch-case的变量冲突？

信号本身是整型数值，管道中传递的是ASCII码表中整型数值对应的字符。

switch的变量一般为字符或整型，当switch的变量为字符时，case中可以是字符，也可以是字符对应的ASCII码。

# 定时器及其容器设计、定时任务的处理
定时器设计，将连接资源和定时事件等封装起来，具体包括连接资源connfd、超时时间和定时事件(清理超时连接）。

定时器容器设计，将多个定时器串联组织起来统一处理，具体包括升序链表设计。

定时任务处理函数，该函数封装在容器类中，具体的，函数遍历升序链表容器，根据超时时间，处理对应的定时器。
## 定时器设计
项目中将连接资源、定时事件和超时时间封装为定时器类，具体的，

连接资源包括客户端套接字地址、文件描述符和定时器

定时事件为回调函数，将其封装起来由用户自定义，这里是删除socket上的注册事件，并关闭连接，连接数减一

定时器超时时间 = 浏览器和服务器连接时刻 + 固定时间(TIMESLOT)，可以看出，定时器使用 绝对时间 作为超时值，这里alarm设置为5秒，连接超时为15秒。
```cpp

 class util_timer;
struct client_data//连接资源包括客户端套接字地址、文件描述符和定时器,这里干什么用？
{
    sockaddr_in address;
    int sockfd;
    util_timer *timer;
};

class util_timer
{
public:
    util_timer() : prev(NULL), next(NULL) {}

public:
    time_t expire;//超时时间
    void (*cb_func)(client_data *);//回调函数，清理不活跃的连接，从内核事件表删除事件，关闭文件描述符，释放连接资源
    client_data *user_data;//连接资源
    util_timer *prev;
    util_timer *next;
};
```

## 定时器容器设计
项目中的定时器容器为带头尾结点的升序双向链表，具体的为每个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排列。执行定时任务时，将到期的定时器从链表中删除。

从实现上看，主要涉及双向链表的插入，删除操作，其中添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)。

## 定时任务处理函数
使用统一事件源，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。

具体的逻辑如下，

遍历定时器升序链表容器，从头结点开始依次处理每个定时器，直到遇到尚未到期的定时器

若当前时间小于定时器超时时间，跳出循环，即未找到到期的定时器

若当前时间大于定时器超时时间，即找到了到期的定时器，执行回调函数清理连接，然后将它从链表中删除，然后继续遍历
```cpp
//SIGALRM信号每次被触发，执行定时任务处理函数
void tick()
    {
        if (!head)
        {
            return;
        }
        //printf( "timer tick\n" );
        LOG_INFO("%s", "timer tick");
        Log::get_instance()->flush();
        //获取当前时间
        time_t cur = time(NULL);
        util_timer *tmp = head;
        while (tmp)
        {    //链表容器为升序排列
          //当前时间小于定时器的超时时间，后面的定时器也没有到期
            if (cur < tmp->expire)
            {
                break;
            }
            //当前定时器到期，则调用回调函数，执行定时事件
            tmp->cb_func(tmp->user_data);
            //将处理后的定时器从链表容器中删除，并重置头结点
            head = tmp->next;
            if (head)
            {
                head->prev = NULL;
            }
            delete tmp;
            tmp = head;
        }
    }
  ```
## 代码分析-如何使用定时器
服务器首先创建定时器容器链表，然后用统一事件源将异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。

具体的，

浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到链表上

处理异常事件时，执行定时事件(服务器关闭连接)，从链表上移除对应定时器

处理定时信号时，将定时标志设置为true??

处理读事件时，若某连接上发生读事件，将对应定时器向后移动，否则，执行定时事件??

处理写事件时，若服务器通过某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件??

